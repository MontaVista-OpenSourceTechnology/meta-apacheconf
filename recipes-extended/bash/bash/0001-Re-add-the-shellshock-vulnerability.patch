From fc763166c451a4633cc46d7f92a42bb07aa058d5 Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Mon, 24 Oct 2022 11:00:56 -0500
Subject: [PATCH] Re-add the shellshock vulnerability

This is for testing, obviously, don't use this in production.

Signed-off-by: Corey Minyard <cminyard@mvista.com>
---
 builtins/evalstring.c |  3 +-
 variables.c           | 78 ++++++++++---------------------------------
 2 files changed, 19 insertions(+), 62 deletions(-)

diff --git a/builtins/evalstring.c b/builtins/evalstring.c
index 18928a17..8c00066e 100644
--- a/builtins/evalstring.c
+++ b/builtins/evalstring.c
@@ -406,7 +406,7 @@ parse_and_execute (string, from_file, flags)
 	      if (flags & SEVAL_FUNCDEF)
 		{
 		  char *x;
-
+#if 0
 		  /* If the command parses to something other than a straight
 		     function definition, or if we have not consumed the entire
 		     string, or if the parser has transformed the function
@@ -423,6 +423,7 @@ parse_and_execute (string, from_file, flags)
 		      reset_parser ();
 		      break;
 		    }
+#endif
 		}
 
 	      bitmap = new_fd_bitmap (FD_BITMAP_SIZE);
diff --git a/variables.c b/variables.c
index 73f157fb..28cb03a9 100644
--- a/variables.c
+++ b/variables.c
@@ -85,11 +85,6 @@
 #define FUNCTIONS_HASH_BUCKETS	512
 #define TEMPENV_HASH_BUCKETS	4	/* must be power of two */
 
-#define BASHFUNC_PREFIX		"BASH_FUNC_"
-#define BASHFUNC_PREFLEN	10	/* == strlen(BASHFUNC_PREFIX */
-#define BASHFUNC_SUFFIX		"%%"
-#define BASHFUNC_SUFFLEN	2	/* == strlen(BASHFUNC_SUFFIX) */
-
 /* flags for find_variable_internal */
 
 #define FV_FORCETEMPENV		0x01
@@ -302,7 +297,7 @@ static void push_temp_var PARAMS((PTR_T));
 static void propagate_temp_var PARAMS((PTR_T));
 static void dispose_temporary_env PARAMS((sh_free_func_t *));     
 
-static inline char *mk_env_string PARAMS((const char *, const char *, int));
+static inline char *mk_env_string PARAMS((const char *, const char *));
 static char **make_env_array_from_var_list PARAMS((SHELL_VAR **));
 static char **make_var_export_array PARAMS((VAR_CONTEXT *));
 static char **make_func_export_array PARAMS((void));
@@ -377,35 +372,24 @@ initialize_shell_variables (env, privmode)
 #if defined (FUNCTION_IMPORT)
       /* If exported function, define it now.  Don't import functions from
 	 the environment in privileged mode. */
-      if (privmode == 0 && read_but_dont_execute == 0 && 
-          STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN) &&
-          STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN) &&
-	  STREQN ("() {", string, 4))
+      if (privmode == 0 && read_but_dont_execute == 0 && STREQN ("() {", string, 4))
 	{
-	  size_t namelen;
-	  char *tname;		/* desired imported function name */
-
-	  namelen = char_index - BASHFUNC_PREFLEN - BASHFUNC_SUFFLEN;
-
-	  tname = name + BASHFUNC_PREFLEN;	/* start of func name */
-	  tname[namelen] = '\0';		/* now tname == func name */
-
 	  string_length = strlen (string);
-	  temp_string = (char *)xmalloc (namelen + string_length + 2);
+	  temp_string = (char *)xmalloc (3 + string_length + char_index);
 
-	  memcpy (temp_string, tname, namelen);
-	  temp_string[namelen] = ' ';
-	  memcpy (temp_string + namelen + 1, string, string_length + 1);
+	  strcpy (temp_string, name);
+	  temp_string[char_index] = ' ';
+	  strcpy (temp_string + char_index + 1, string);
 
 	  /* Don't import function names that are invalid identifiers from the
 	     environment in posix mode, though we still allow them to be defined as
 	     shell variables. */
-	  if (absolute_program (tname) == 0 && (posixly_correct == 0 || legal_identifier (tname)))
-	    parse_and_execute (temp_string, tname, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
+	  if (legal_identifier (name))
+	    parse_and_execute (temp_string, name, SEVAL_NONINT|SEVAL_NOHIST|SEVAL_FUNCDEF|SEVAL_ONECMD);
 	  else
 	    free (temp_string);		/* parse_and_execute does this */
 
-	  if (temp_var = find_function (tname))
+	  if (temp_var = find_function (name))
 	    {
 	      VSETATTR (temp_var, (att_exported|att_imported));
 	      array_needs_making = 1;
@@ -418,11 +402,8 @@ initialize_shell_variables (env, privmode)
 		  array_needs_making = 1;
 		}
 	      last_command_exit_value = EXECUTION_FAILURE;
-	      report_error (_("error importing function definition for `%s'"), tname);
+	      report_error (_("error importing function definition for `%s'"), name);
 	    }
-
-	  /* Restore original suffix */
-	  tname[namelen] = BASHFUNC_SUFFIX[0];
 	}
       else
 #endif /* FUNCTION_IMPORT */
@@ -3673,7 +3654,7 @@ assign_in_env (word, flags)
   var->context = variable_context;	/* XXX */
 
   INVALIDATE_EXPORTSTR (var);
-  var->exportstr = mk_env_string (newname, value, 0);
+  var->exportstr = mk_env_string (newname, value);
 
   array_needs_making = 1;
 
@@ -4708,9 +4689,8 @@ flush_temporary_env ()
 /* **************************************************************** */
 
 static inline char *
-mk_env_string (name, value, isfunc)
+mk_env_string (name, value)
      const char *name, *value;
-     int isfunc;
 {
   size_t name_len, value_len;
   char	*p, *q, *t;
@@ -4718,38 +4698,14 @@ mk_env_string (name, value, isfunc)
   name_len = strlen (name);
   value_len = STRLEN (value);
 
-  /* If we are exporting a shell function, construct the encoded function
-     name. */
-  if (isfunc && value)
-    {
-      p = (char *)xmalloc (BASHFUNC_PREFLEN + name_len + BASHFUNC_SUFFLEN + value_len + 2);
-      q = p;
-      memcpy (q, BASHFUNC_PREFIX, BASHFUNC_PREFLEN);
-      q += BASHFUNC_PREFLEN;
-      memcpy (q, name, name_len);
-      q += name_len;
-      memcpy (q, BASHFUNC_SUFFIX, BASHFUNC_SUFFLEN);
-      q += BASHFUNC_SUFFLEN;
-    }
-  else
-    {
-      p = (char *)xmalloc (2 + name_len + value_len);
-      memcpy (p, name, name_len);
-      q = p + name_len;
-    }
+  p = (char *)xmalloc (2 + name_len + value_len);
+  memcpy (p, name, name_len);
+  q = p + name_len;
 
   q[0] = '=';
   if (value && *value)
     {
-      if (isfunc)
-	{
-	  t = dequote_escapes (value);
-	  value_len = STRLEN (t);
-	  memcpy (q + 1, t, value_len + 1);
-	  free (t);
-	}
-      else
-	memcpy (q + 1, value, value_len + 1);
+      memcpy (q + 1, value, value_len + 1);
     }
   else
     q[1] = '\0';
@@ -4847,7 +4803,7 @@ make_env_array_from_var_list (vars)
 	  /* Gee, I'd like to get away with not using savestring() if we're
 	     using the cached exportstr... */
 	  list[list_index] = USE_EXPORTSTR ? savestring (value)
-					   : mk_env_string (var->name, value, function_p (var));
+					   : mk_env_string (var->name, value);
 	  if (USE_EXPORTSTR == 0)
 	    SAVE_EXPORTSTR (var, list[list_index]);
 
-- 
2.34.1

